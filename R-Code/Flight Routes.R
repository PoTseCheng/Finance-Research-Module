# This code is probably quite hard to read if you have never used
# parallel computing. Furthermore, the code itself is quite com-
# plex. Firstly to reduce computational time, secondly, flight
# routing can be quite complex


# I try to explain it as good and as simple as possible:
#
# This are the main parts:
#
# 1) get_flights_summary --> creates a list of all available
#    flights within the given period
#
# 2) find_fastest_flight --> returns for the given airport
#    codes the fastest routing between them basing on the 
#    given flight schedule (takes roughly 1s per routing)
#
# 3) compute_facility_journey --> does the flight routing for
#    a facility. This can be split in two problems: i) Find the
#    closest airports for lender and borrower and ii) find the 
#    fastest routing between the closest airports. This function
#    bases also on python-code (see r-package reticulate).
#    It returns then the route of the fastest flight
#
# 4) compute_monthly_facilities_journeys --> does the flight
#    routing for an entire month. So it takes all facilities
#    of a month and calls for each compute_facility_journey
#
# 5) compute_facilites_journeys --> does the flight routing
#    for the entire sample.
#
# 6) compute_air_traveling --> is a wrapper for the function
#    compute_facilites_journeys, prepares the function call
#    and shows the current progress


# Why is flight routing so time intensive? There are thousands
# of airports available, each has thousands of flights. So there
# are basically infinite many ways one could choose and each 
# could be the best solution. Moreover, as soon as you consider
# more than one airport, the constellation grows exponentionally.
# Closest airport: exact 1 routings; 2 closest airports: 4 routings.
# So the computional time increases by 4 and we consider the 
# cloest 3 airports.


# ROAD MAP OF THIS FILE:
#
#    Section: Functions for Routing
#    Section: Routing Functions
#    Section: Application of Routing
#
# Next step: 




######################################################################
######################################################################
####### SECTION: FUNCTIONS FOR ROUTING
# These functions are required for the routing function itself

# This function takes as input a list of all flights in a month,
# it then excludes all unsuitable flights and returns a flights
# schedule:
# -> The schedule has one entry per airport constellation, it
#    assumes that all carriers are one company
# -> The schedule contains the median flight time:
# -> Airport Origination | Airport Destination | Median Flight Time
get_flights_summary <- function(flights.list) {
  # Filter flights here, only performed passenger flights
  flights.summary <- flights.list %>% filter(SEATS > 0 & AIR_TIME > 0 & DEPARTURES_PERFORMED > 0)
  flights.summary <- flights.summary %>% mutate(AIR_TIME = AIR_TIME / DEPARTURES_PERFORMED)
  
  # Compute median
  flights.summary <- flights.summary %>% group_by(ORIGIN, DEST)
  flights.summary <- flights.summary %>% summarise(
    MeanAirTime = weightedMedian(AIR_TIME, DEPARTURES_PERFORMED, interpolate = FALSE)
  )
  
  # Return data
  return(flights.summary %>% rename(Origination = ORIGIN, Destination = DEST))
}


# This function is the actual function that computes the flight
# time between airport A and airport B. It expects the airport
# code of the destination and origination as well as the flight
# schedule generated by the function above
#
# The function uses pyhton as well (py_run_string). You can exe-
# cute python code in R. Due to parallel computing one must put
# the entire function in one string ...
#
# Requires the following python packages:
#  i)
# ii)
# 
# The function returns a data frame that contains the flight
# routing.
find_fastest_flight <- function(origination, destination, flights.list) {
  py_run_string('
                
#!/usr/bin/env python
# coding: utf-8

# In[ ]:


import pandas as pd
from collections import defaultdict
from heapq import *


# In[ ]:


#Define function reader:
def reader(test2):
    test2=test2[["Origination","Destination","MeanAirTime"]] #just to make sure only take the right columns
    test2 = test2.rename(columns={"Origination": "start", "Destination": "end", "MeanAirTime": "airtime"}) #assumed that passenger will want to take the time with least air routes

    #make sure the datatype is correct
    test2["start"]=test2["start"].astype(str)
    test2["end"]=test2["end"].astype(str)
    tuples = test2.to_records(index=False).tolist() #list of tuples to constuct the edges

    return tuples, test2

#Define Dijkstra function:
def dijkstra(edges, f, t):
    g = defaultdict(list) #construct dictionary by the list, in this case, edges
    for l,r,c in edges:
        g[l].append((c,r))

    q, seen, mins = [(0,f,())], set(), {f: 0}
    while q:
        (cost,v1,path) = heappop(q) #see https://pythontic.com/algorithms/heapq/heappop#:~:text=The%20heappop()%20function%20removes,to%20maintain%20the%20heap%20invariant.
        if v1 not in seen:
            seen.add(v1)
            path = (v1, path)
            if v1 == t: return (cost, path)

            for c, v2 in g.get(v1, ()):
                if v2 in seen: continue
                prev = mins.get(v2, None)
                next = cost + c
                if prev is None or next < prev:
                    mins[v2] = next
                    heappush(q, (next, v2, path))

    return float("inf")
#Define wrapper function:
def wrapper(Origination, Destination, original_df):
    tuples, df = reader(original_df)
    edges = tuples
    make_path = lambda tup: (*make_path(tup[1]), tup[0]) if tup else ()
    out = dijkstra(edges, Origination, Destination)
    if out == float("inf"):
        total_time = None
        route = False
        realpath = float("NaN")
        path = float("NaN")
        first_leg = float("NaN")
        last_leg = float("NaN")
    else:
        path = make_path(out[1])
        realpath = list(path)
        realpath = "-".join(realpath)
        total_time = str(out[0])
        route = True
        first_leg = path[0]+ "-"+ path[1]
        last_leg = path[len(path)-2]+"-"+path[len(path)-1]
    #build a dictionary
    dic = {"Route Existance": route, "Total Time": total_time, "Total Pathway": str(realpath), "First Leg": first_leg, "Last Leg": last_leg}
    #build dataframe
    df = pd.DataFrame(data=dic, index=[0])

    return df
                ');
  
  
  # Get flight route data
  flight.data <- py$wrapper(origination, destination, flights.list)
  found.route <- flight.data %>% pull("Route Existance")
  
  
  if (found.route) {
    result <- tibble(
      Origination = origination,
      Destination = destination,
      AirTime = flight.data %>% pull("Total Time"),
      Routing = flight.data %>% pull("Total Pathway"),
      FirstFlight = flight.data %>% pull("First Leg"),
      LastFlight = flight.data %>% pull("Last Leg"),
    )
    
  } else {
    result <- tibble(
      Origination = origination,
      Destination = destination,
      AirTime = NA,
      Routing = NA,
      FirstFlight = NA,
      LastFlight = NA,
    )
  }
  
  return(result)
}

# This function compares candidate offers a faster connection
# than the benchmark. Both inputs must be a flight routing
# generated by faster flight. It returns true if candidate
# is faster.
is_faster_air_route <- function(candidate, benchmark) {
  # There is no (valid) benchmark
  if (!is.data.frame(benchmark)) {
    return(TRUE)
  }
  
  # Get air times
  benchmark.air.time <- benchmark %>% pull(AirTime)
  candidate.air.time <- candidate %>% pull(AirTime)
  
  # Handle non existing connection
  if (is.na(candidate.air.time)) {
    return(FALSE)
  }
  
  if (is.na(benchmark.air.time)) {
    return(TRUE)
  }
  
  # Compare
  return(candidate.air.time < benchmark.air.time)
}

# This function returns a list of all airports that are listed
# in the as input given flight summary generated by our
# flight summary function
get_available_airports <- function(flights.summary) {
  return(list(
    Originations = flights.summary %>% pull(Origination) %>% unique(),
    Destinations = flights.summary %>% pull(Destination) %>% unique()
  ))
}

# This function returns a list of the closest aiprorts from the
# given start location. Available.airports must be generated by
# get_available_airports and distance is a distance database
# listing all distances. n defines the number of airports that
# are returned at most. This is a restriction due to computational
# reasons. Without the flight routing computation time would
# increase even more.
get_closest_airports <- function(starting.lat, starting.lon, available.airports, distances = distance.airport.database, n = 5) {#3
  # Keep only distance that address the starting ppoint
  distances <- distances %>% filter(FromLat == starting.lat & FromLon == starting.lon)
  distances <- distances %>% select(-FromLat, -FromLon) %>% distinct(AirportLat, AirportLon, .keep_all = TRUE)
  
  # Remove unavailable airports
  airports <- distances %>% filter(AirportCode %in% available.airports)
  
  # Return suitables
  if(nrow(airports) > 0) {
    return(
      airports %>% mutate(Rank = 1:nrow(airports)) %>% slice(1:n)
    )
  }
  
  return(tibble())
}




######################################################################
######################################################################
####### SECTION: ROUTING FUNCTIONS
# This section is written to allow parallel compution for the routing
# and implements the actual routing functions

# This function calls the flight routing procedure for one facility.
# It basically uses all functions of the previous section. Note that
# the lag is fixed, i.e. that is defined on the calling function.
compute_facility_journey <- function(facility, available.airports, flights.summary, distances, max.distance.to.airport = c(125, 250, 350, 450)) {
  # Conver to km
  max.distance.to.airport <- max.distance.to.airport * 1000
  
  
  # Get borrower data
  borrower.lat <- facility %>% pull(BorrowerLat)
  borrower.lon <- facility %>% pull(BorrowerLon)
  all.borrower.airports <- get_closest_airports(borrower.lat, borrower.lon, available.airports$Destinations, distances)
  all.borrower.airports <- all.borrower.airports %>% filter(Distance < max(max.distance.to.airport))
  
  # Get lender data
  lender.lat <- facility %>% pull(LenderLat)
  lender.lon <- facility %>% pull(LenderLon)
  all.lender.airports <- get_closest_airports(lender.lat, lender.lon, available.airports$Originations, distances)
  all.lender.airports <- all.lender.airports %>% filter(Distance < max(max.distance.to.airport))
  
  
  # Remove to remote airports
  distance.limit <- 1
  if (length(max.distance.to.airport) > 1) {
    # .. if more than one distance limit, try it stepwise
    # -> first take relatively close ones and ignore further remote ones,
    #    but if there is no one close-by, consider more remote ones.
    
    for (current.distance.limit in max.distance.to.airport) {
      # Remove airports
      borrower.airports <- all.borrower.airports %>% filter(Distance < current.distance.limit)
      lender.airports <- all.lender.airports %>% filter(Distance < current.distance.limit)
      
      # Leave loop if airport is close
      if (nrow(borrower.airports) > 0 && nrow(lender.airports) > 0) {
        break;
      }
      
      distance.limit <- distance.limit + 1
    }
    
  } else {
    # ... if just one distance limit, use this one (was already above applied)
    borrower.airports <- all.borrower.airports
    lender.airports <- all.lender.airports
  }
  
  
  # Make sure that there exists still at least one airport for each of them
  if (nrow(borrower.airports) > 0 && nrow(lender.airports) > 0) {
    
    # Try to find the shortest connection, to do so:
    # Find faster air route for each pair of borrower and lender airports
    fastest.routing <- NULL
    
    # Loop lenders potential airports
    for (i in 1:nrow(lender.airports)) {
      lenders.choice <- lender.airports[i,] %>% pull(AirportCode)
      
      # Loop borrowers potential airports
      for (j in 1:nrow(borrower.airports)) {
        borrowers.choice <- borrower.airports[j,] %>% pull(AirportCode)
        
        # Avoid flying from and to the same airport
        if (lenders.choice != borrowers.choice) {
          
          # Compute travel time
          flight <- find_fastest_flight(lenders.choice, borrowers.choice, flights.summary)
          
          # Must be a valid connection
          if (is.data.frame(flight) && is_faster_air_route(flight, fastest.routing)) {
            fastest.routing <- flight %>% mutate(
              OriginationLat = lender.airports[i,] %>% pull(AirportLat),
              OriginationLon = lender.airports[i,] %>% pull(AirportLon),
              DestinationLat = borrower.airports[j,] %>% pull(AirportLat),
              DestinationLon = borrower.airports[j,] %>% pull(AirportLon),
              TravelDistanceLimit = distance.limit
            )
          }
        }
      }
    }
    
    if (!is.null(fastest.routing) && !is.na(fastest.routing %>% pull(AirTime))) {
      # Transform output
      fastest.routing <- fastest.routing %>% rename(
        LenderAirport = Origination,
        LenderAirportLat = OriginationLat,
        LenderAirportLon = OriginationLon,
        BorrowerAirport = Destination,
        BorrowerAirportLat = DestinationLat,
        BorrowerAirportLon = DestinationLon,
        FlightTime = AirTime,
        FlightRouting = Routing,
        FlightFirstLeg = FirstFlight,
        FlightLastLeg = LastFlight,
        DistanceLimit = TravelDistanceLimit
      ) %>% mutate(
        FacilityID = facility %>% pull(FacilityID),
        LenderCompanyID = facility %>% pull(LenderCompanyID)
      )
      
      # Return journey data
      return(fastest.routing)
    }
  }
  
  # Fallback
  return(NULL)
}



# This function does the flight routing for all facilities of month,
# it calls foreach facility of the month compute_facility_journey
# and then merges the data. Note the lag is fixed at the function
# calling this function
compute_monthly_facilities_journeys <- function(facilities, flights.data, distances) {
  # Load air data
  flights.summary <- get_flights_summary(flights.data)
  available.airports <- get_available_airports(flights.summary)
  
  # Finding the best air connection for each given facility
  routes <- NULL
  n <- nrow(facilities)
  
  if (n > 0) {
    for (i in 1:n) {
      
      facility <- facilities %>% slice(i)
      journey <- compute_facility_journey(facility, available.airports, flights.summary, distances)
      
      if (!is.null(journey)) {
        routes <- rbind(
          routes,
          journey
        )
      }
    }
  }
  
  return(routes)
}



# This function does the flight routing for the entire sample. It
# also does that for the given amount of lags. Distances is a dis-
# tance database. This function uses parallel computing due to the
# very long computational time of this stuff. Just to give you a 
# hint of the computation time: 1 lags takes roughly about 14 hours
# to compute at full usage of the computational power.
compute_facilites_journeys <- function(all.facilities, lag.in.months, years, distances, base.dir) {
  # Enable fast computing
  do.par <- TRUE # @ HARDCODED
  if (do.par) {
    library(doParallel)
    library(doSNOW)
  }
  
  # Loop each month in each year to get the monthly air routing
  journeys <- NULL
  last.year.facility <- NULL
  
  for (year.facility in years) {
    # @ ADD THIS LINE IF DO PAR (on year level)
    #last.year.facility <- NULL
    
    print(paste0(Sys.time(), " - Current year: ", year.facility, " of ", max(years), " // current lag: ", lag.in.months))
    
    # Start set up of paralell computing // Start of do.par
    if (do.par) {
      # General settings
      cores <- 6 # @ NUMBER OF CORES
      cluster <- makeCluster(cores)
      registerDoSNOW(cluster)
      
      # Progressbar
      progress.bar <- txtProgressBar(min = 1, max = 12, style = 3)
      progressing <- function(n) {
        setTxtProgressBar(progress.bar, n)
      }
      
      
      # Exports
      exporting.packages <- c("dplyr", "stringr", "lubridate", "readr", "reticulate", "matrixStats")
      exporting.options <- list(progress = progressing)
      exporting.normal <- c(
        # Functions
        "convert_date", "add_trailing_zero", "compute_monthly_facilities_journeys", "compute_facility_journey",
        "get_available_airports", "get_flights_summary", "is_faster_air_route", "find_fastest_flight", "get_closest_airports",
        # Variables
        "year.facility", "lag.in.months", "do.par", "all.facilities", "distances", "working.dir", "unique.locations",
        "last.year.facility", "py_run_string"
      )
    }
    # // End of do.par
    
    
    # Acutal computing (but handling do par)
    # Use on of the two following line:
    # (i)   first following line, if parallel computing
    # (ii)  second following line, if normal computing
    routings <- foreach (i = 1:12, .combine = rbind, .export = exporting.normal, .packages = exporting.packages, .options.snow = exporting.options) %dopar% {
      #for (month.facility in 1:12) {
      
      # Get a leading zero to months in 1:9
      #month.facility <- add_trailing_zero(month.facility) # BEFORE DO PAR
      month.facility <- add_trailing_zero(i)
      
      
      facility.date.min <- paste0(year.facility, month.facility, "01") %>% ymd
      facility.date.max <- rollback(facility.date.min + months(1))
      
      lags.date.min <- facility.date.min - months(lag.in.months)
      lags.date.max <- rollback(lags.date.min + months(1))
      
      
      # Cache air data if possible, if not possible, load it
      if (is.null(last.year.facility) || is.na(last.year.facility) || last.year.facility != year(lags.date.min)) {
        # Since cache does not contain them, load it
        air.routes.file <- paste0(ifelse(do.par, working.dir, base.dir), "Import/Air Routes - ", year(lags.date.min), ".csv")
        
        # Check if the actual data exists
        if (!file.exists(air.routes.file)) {
          if (do.par) {
            return(NULL)
          } else {
            next;
          }
        }
        
        # Load flights data
        annual.flights.data <- suppressWarnings(read_csv(air.routes.file))
        last.year.facility <- ifelse(do.par, NA, year(lags.date.min))
      }
      
      
      # Update the monthly data
      monthly.flights.data <- annual.flights.data %>% filter(MONTH == month(lags.date.min))
      monthly.facilities <- all.facilities %>% filter(
        FacilityStartDate >= convert_date(facility.date.min) & FacilityStartDate <= convert_date(facility.date.max)
      )
      
      
      # Enure that there is data
      if (nrow(monthly.facilities) == 0 || nrow(monthly.flights.data) == 0) {
        if (do.par) {
          return(NULL)
        } else {
          next;
        }
      }
      
      
      # Then compute the journeys
      routings <- compute_monthly_facilities_journeys(monthly.facilities, monthly.flights.data, distances)
      
      
      if (do.par) {
        return(routings)
      } else {
        journeys <- rbind(
          journeys,
          routings
        )
      }
    }
    
    # Stop parallel computing stuff // "Start" of do.par
    if (do.par) {
      close(progress.bar)
      stopCluster(cluster)
      cluster <- NULL
      
      journeys <- rbind(
        journeys,
        routings
      )
    } #  // End of do.par
  }
  
  
  if (!is.null(journeys) && nrow(journeys) > 0) {
    return(journeys %>% mutate(Lag = lag.in.months))
  }
  
  return(NULL)
}



# This is the function that calls the entire flight routing pro-
# cedure. It returns all facilities with their flight route if
# such route exists.
compute_air_traveling <- function(all.facilities, lags.in.months, years = observation.period, distances = distance.database, locations = unique.locations, base.dir = working.dir) {
  computation.time.start <- Sys.time()
  
  # Transform distance database 
  distances <- distances %>% rename(AirportLat = ToLat, AirportLon = ToLon) %>% left_join(
    locations %>% filter(Airport == TRUE) %>% select(Lat, Lon, LocationString) %>% rename(AirportLat = Lat, AirportLon = Lon),
    by = c("AirportLat", "AirportLon")
  )
  distances <- distances %>% filter(!is.na(LocationString)) %>% rename(AirportCode = LocationString)
  distances <- distances %>% mutate(AirportCode = str_to_upper(str_sub(AirportCode, start = 1, end = 3)))
  
  # Loop for the requested number of lags
  lag.data <- NULL
  for (lag in min(lags.in.months):max(lags.in.months)) {
    print("================================================")
    print("================================================")
    print(paste0("Currently: ", lag, " lag of ", max(lags.in.months), " lags"))
    
    data <- compute_facilites_journeys(all.facilities, lag, years, distances, base.dir)
    
    lag.data <- rbind(
      lag.data,
      data
    )
  }
  
  
  computation.time.end <- Sys.time()
  
  print("================================================")
  print("================================================")
  print("Computation finished, begin merging")
  
  # Append this data // Merge with facility data
  for (current.lag in min(lags.in.months):max(lags.in.months)) {
    current.lag.data <- lag.data %>% filter(Lag == current.lag) %>% select(-Lag)
    
    # Rename
    protected.colnames <- c("FacilityID", "LenderCompanyID")
    new.colnames <- colnames(current.lag.data)
    new.colnames <- if_else(new.colnames %in% protected.colnames, new.colnames, paste0("L", current.lag, new.colnames))
    current.lag.data <- setNames(current.lag.data, new.colnames)
    
    # Then add to actual data frame
    all.facilities <- all.facilities %>% left_join(current.lag.data, by = c("FacilityID", "LenderCompanyID"))
  }
  
  print("================================================")
  print("================================================")
  print("Merging finished")
  print("Statistics:")
  print(paste0("- Computation started:      ", computation.time.start))
  print(paste0("- Computation finished:     ", computation.time.end))
  print(paste0("- Merging finished:         ", Sys.time()))
  print(paste0(
    "- Observations without any air routes available: ",
    length(which(is.na(all.facilities[,paste0("L", min(lags.in.months), "FlightTime")]))), " #",
    "  ( ", round(
      length(which(is.na(all.facilities[,paste0("L", min(lags.in.months), "FlightTime")]))) / nrow(all.facilities) * 100,
      digits = 4
    ), " % )"
  ))
  
  # Return the final data
  return(all.facilities)
}






######################################################################
######################################################################
####### SECTION: APPLICATION OF ROUTING
# Here happens the actual flight routing

# Do partial exclusion here (see paper) to speed up the computation
facility.data <- facility.data %>% filter(!is.na(BorrowerSICCode))
facility.data <- facility.data %>% filter(!is.na(BorrowerCounty))
facility.data <- facility.data %>% filter(BorrowerLenderDistance > 150)
facility.data <- facility.data %>% arrange(FacilityStartDate)


# In case sub sampling should be tried
if (do.flight.routing.test) {
  facility.data <- facility.data %>% filter(FacilityStartDate < 19910101)
  facility.data <- facility.data %>% sample_n(1000)
  
  max.lags <- 4
  observation.period <- 1990:1991
}
  
# Define required columns for location such that we reduce
# memory usage during the routing process
routing.input <- facility.data[,c(
  "FacilityID",
  "PackageID",
  "BorrowerCompanyID",
  "LenderCompanyID",
  "FacilityStartDate",
  "BorrowerLon",
  "BorrowerLat",
  "LenderLat",
  "LenderLon"
)]
  
# Get current facility data out of memory to save memory
tmp.facility.data <- paste0(working.dir, "Temporary/Before Flight Routing.rds")
write_rds(facility.data, path = tmp.facility.data)
facility.data <- NULL
  
# Do the routing
flight.routing.data <- compute_air_traveling(
  all.facilities = routing.input,
  lags = 1:max.lags,
  years = observation.period,
  distances = distance.database,
  locations = unique.locations,
  base.dir = working.dir
)
  
routing.input <- NULL
  
# Restore facility data
facility.data <- read_rds(tmp.facility.data)


# Merge routed and facility data
facility.data <- facility.data %>% left_join(
  flight.routing.data,
  by = c(
    "FacilityID",
    "PackageID",
    "BorrowerCompanyID",
    "LenderCompanyID",
    "FacilityStartDate",
    "BorrowerLon",
    "BorrowerLat",
    "LenderLat",
    "LenderLon"
  ))

flight.routing.data <- NULL


